<!DOCTYPE html>
<html>
	<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta charset="utf-8">
  <title>DataTable - WebComponent</title>
  <!-- <link rel="stylesheet" href="normalize.css"> -->
 

</head>

<body>

</body>
</html>

<script>

/*Null or undefined  --> if ( value == null ) // checks the two conditions*/

function isJSON(str) 
{
    if ( /^\s*$/.test(str) ) return false;
    str = str.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@');
    str = str.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']');
    str = str.replace(/(?:^|:|,)(?:\s*\[)+/g, '');
    return (/^[\],:{}\s]*$/).test(str);
}

class FormReader extends Map
{
	constructor()
	{
		super();
	}

	set( key, value )
	{
		if ( typeof(key)=='string' || key instanceof String  && ( value instanceof Function || value instanceof FormReader ))
		{
			super.set(key,value);
		}
		else
		{
			console.error('Form field needs to be a String. Form values needs to be a Function or another FormReader');
		}
	}

	jsObject()
	{
		let obj = {};

		for( let [field, value] of this.entries() )
		{
			obj[ field.toString() ] = value();
		}

		return obj;
	}

	json()
	{
		return JSON.stringify( this.jsObject() );
	}
}


function mapToJSON( map )
{
	let obj = {};

	for( let [field, value] of map.entries() )
	{
		obj[ field.toString() ] = value;
	}

	return JSON.stringify(obj);
}


class HTMLDataTablePaginatorElement extends HTMLElement
{
	constructor()
	{
		super();		
 	
 		this.filterInput = document.createElement('input');
 		this.filterInput.type = 'text';
 		this.filterInput.placeholder = 'Search...';
 		this.filterInput.classList.add('input-text--search');

		this.previous = document.createElement('button');
		this.next = document.createElement('button');
		this._pagesize = document.createElement('select');
		this.previous.innerText = 'previous';	
		this.next.innerText = 'next';
		this.first = document.createElement('button');
		this.last = document.createElement('button');

		this.first.innerText = 'first';
		this.last.innerText = 'last';
		
		this.message = document.createElement('p');


		for( let ps of [10,15,20,50]) this.addPageSizeOption(ps,ps);
		
		//this.pagesize = 10;
		this._pageNumber = 1;

		//re-importante esto va si o si aca... en la callback connected se ejecuta solo cuando alguien hace append y no se sabe en que orden hace el addEventListener
		//en el constructor aseguramos que es en el primer lugar, aunque no tecnicamente el botón no esté disponible en la UI en esta fase.
	}

	connectedCallback()
	{
		let div = document.createElement('span');	
		div.appendChild(this.filterInput);
		div.appendChild(this._pagesize);
		div.appendChild(this.first);
		div.appendChild(this.previous);
		div.appendChild(this.next);
		div.appendChild(this.last);
		div.appendChild(this.message);
		this.appendChild( div );		
	}

	addPageSizeOption( value, text )
	{
		let option = document.createElement('option');
		option.text = text;
		option.value = value;
		this._pagesize.add(option);
	}

	get pagesize()
	{
		return this._pagesize;
	}

	set pagesize( value )
	{
		let current=-1;

		for( let idx=0; idx < this._pagesize.options.length; idx++)
		{
			if( this._pagesize.options[idx].value == value )
				current=idx;
		}

		if ( current != -1)
			this._pagesize.selectedIndex = current;
	}

	get pageNumber()
	{
		return this._pageNumber;
	}

	set pageNumber( aNumber )
	{
		this._pageNumber = aNumber;
		this.updateMessage();
	}
	
	updateMessage()
	{
		this.message.innerText = 'Page: '+this._pageNumber;
	}
}	



class HTMLDataTableColumn extends HTMLTableCellElement
{
	constructor()
	{
		super();

		this._arrow = document.createElement('span');
		this._title = document.createElement('span');

		//default
		this.classList.toggle('unsortable-column');
		this._title.classList.add('column-title');
		this.ascending = undefined;

		this.appendChild(this._title);
		this.appendChild(this._arrow);

		
	}

	set value( value )
	{
		this._title.innerText = value.toString();
	}

	get value()
	{
		return this._title.innerText;
	}

	get sortable()
	{
		return this.classList.contains('sortable-column');
	}

	set sortable( value )
	{
		if ( typeof value == 'boolean' || value instanceof Boolean )
		{
			this.classList.toggle('sortable-column');
			this.classList.toggle('unsortable-column');
		}
		else
		{
			this.classList.toggle('unsortable-column');
			this.classList.toggle('sortable-column');
		}
	}

	set ascending( value )
	{
		if ( this.sortable ) switch ( value )
		{
			case true:
			{
				this._arrow.classList.remove('sort-arrow-undefined','sort-arrow-descending');
				this._arrow.classList.add('sort-arrow-ascending');
				break;
			};

			case false:
			{
				this._arrow.classList.remove('sort-arrow-ascending','sort-arrow-undefined');
				this._arrow.classList.add('sort-arrow-descending');
				break;
			};

			default:
			{
				this._arrow.classList.remove('sort-arrow-ascending','sort-arrow-descending');
				this._arrow.classList.add('sort-arrow-undefined');
				break;
			};
		}
	}

	get ascending()
	{
		return (this._arrow.classList.contains('sort-arrow-ascending'))? true : this._arrow.classList.contains('sort-arrow-descending')? false : undefined;
	}

	toggle() 
	{
		if ( this.sortable ) switch( this.ascending )
		{
			case true:
			{
				this.ascending = false;
				break;		
			};	

			case false:
			{
				this.ascending = true;
				break;				
			};

			default:
			{
				this.ascending = true;
				break;
			};
		}
	}
}


class HTMLDataTableCellElement extends HTMLTableCellElement
{
	constructor()
	{
		super();
	}

	set value( value )
	{
		this.innerText = value.toString();
	}

	get value()
	{
		return this.innerText;
	}
}

class HTMLEmailCell extends HTMLDataTableCellElement
{
	constructor()
	{
		super();

		this._email = document.createElement('a');
		this.classList.add('td-email');

		this.appendChild(this._email);
	}

	set value( value )
	{
		this._email.href = 'mailto:'+value.toString();
		this._email.innerText = value.toString();
	}

	get value()
	{
		return this._email.innerText;
	}

}

class HTMLTextCell extends HTMLDataTableCellElement
{
	constructor()
	{
		super();
		this._p = document.createElement('span');
		this.classList.add('td-text');
		this.appendChild(this._p);
	}

	set value( value )
	{
		this._p.innerText = value;
	}

	get value()
	{
		return this._p.innerText;
	}

}

class HTMLDataTableRow extends HTMLTableRowElement
{
	constructor()
	{
		super();
	}
}

customElements.define('x-datatable-row', HTMLDataTableRow, { extends:'tr'} );
customElements.define('x-datatable-paginator', HTMLDataTablePaginatorElement );
customElements.define('x-datatable-text-cell', HTMLTextCell, { extends:'td'});
customElements.define('x-datatable-email-cell', HTMLEmailCell, { extends:'td'});
customElements.define('x-datatable-column', HTMLDataTableColumn, { extends:'th'});



class HTMLDataTable extends HTMLElement
{
	constructor()
	{
		super();

		this.attachShadow({ mode: 'open' });

		this._table = document.createElement('table');
		this._table.createTBody();
		this._table.createTHead();
		this._table.createTFoot();

		this.paginator = new HTMLDataTablePaginatorElement();

		let r = this._table.tHead.insertRow();	
		this.setAttribute('sortcolumn','');

		this._sortcolumn = null;
	}

	get header()
	{
		return this._table.tHead;
	}

	get body()
	{
		return this._table.tBodies[0];
	}

	get footer()
	{
		return this._table.tFoot;
	}

	insertColumn( column )
	{
		if ( this._table.tHead.rows[0] == null )
		{
			this._table.tHead.insertRow();
		}

		if( column instanceof HTMLDataTableColumn )
		{
			this._table.tHead.rows[0].appendChild(column);
		}
	}

	deleteColumn( index )
	{
		if ( this._table.tHead.rows[0] != null )
		{
			this._table.tHead.rows[0].deleteCell( index );

			for( let tr of this.rows )
				tr.deleteCell(index);
		}		
	}

	insertRow( input )
	{
		if( input instanceof HTMLDataTableRow )
		{
			this._table.tBodies[0].appendChild(input);
		}
	}

	deleteRow(index)
	{
		this._table.tBodies[0].deleteRow( index );
	}

	clear()
	{
		while( this._table.tBodies[0].childElementCount != 0 )
			this._table.tBodies[0].deleteRow(0);
	}

	get isSorted()
	{
		return ( this.sortcolumn instanceof HTMLDataTableColumn && this.sortcolumn.sortable );
	}
	
	get columns()
	{
		return this._table.tHead.rows[0].cells;
	}

	get rows()
	{
		return this._table.tBodies[0].rows;
	}
	
	get sortcolumn()
	{
		return this._sortcolumn;
	}

	set sortcolumn(value)
	{
		if( value instanceof HTMLDataTableColumn && value.sortable )
		{
			this._sortcolumn = value;
		}
		else
		{
			console.error('Specified column is not sortable.');
			this._sortcolumn = null;
		};
	}

	connectedCallback()
	{
		this.shadowRoot.appendChild( document.createElement('style') );
		this.shadowRoot.styleSheets[0].insertRule("@import 'test.css'");	
		this.shadowRoot.appendChild( this._table );

		//paginator
		let r = this._table.tFoot.insertRow();
		let td = r.insertCell();
		td.setAttribute('colspan', this.columns.length );
		td.style.background = '#F3F3F3';
		td.appendChild( this.paginator );

		
	}

	

	
	message( text )
	{
		this.clear();

		let tr = this._table.tBodies[0].insertRow();
		tr.className = 'empty-row';
		let cell = new HTMLTextCell();		
		cell.setAttribute('colspan', this.columns.length);
		cell.innerText = text.toString();
		tr.appendChild(cell);
	}
	

}



//transform FormData object into QUERY_STRING
//const queryString = new URLSearchParams(formDataObject).toString()

customElements.define('x-datatableview', HTMLDataTable );

class Model
{
	constructor()
	{
		this.form = new Map();

		this.page = 1;
		this.pagesize = 10;
		this.order = null;
		this.ascending = null;
	}

	read()
	{
		return fetch( new Request('post', 'url', body.. ));
	}

}


class HTMLDataTableController extends HTMLController
{
	constructor()
	{
		super();

		this.view = new HTMLDataTable();

		const sort = event => { this.onsort(event); this.submit(); };
		const pagesizechanged = event => { this.onpagesizechange(event); this.submit; };
		const previouspage = event => { this.onpreviouspage(event); this.submit; };
		const lastpage = event => { this.onlastpage(event); this.submit; };
		const firstpage = event => { this.onfirstpage(event); this.submit; };
		const nextpage = event => { this.onnextpage(event); this.submit; };

		this.view.paginator._pagesize.addEventListener('input',  pagesizechanged );		
		this.view.paginator.next.addEventListener('click', nextpage );
		this.view.paginator.last.addEventListener('click', lastpage );
		this.view.paginator.first.addEventListener('click', firstpage );		
		this.view.paginator.previous.addEventListener('click', previouspage );
		this.view.header.addEventListener('click', sort );

		this.autosubmit = true;
		this.form = new Map();
	}

	onpagesizechange()
	{
		//this.model.read().then(....)
	}

	onpreviouspage()
	{
		( this.pageNumber > 1 )? this.pageNumber-- : this.pageNumber=1;
	}

	onlastpage()
	{

	}

	onfirstpage()
	{
		this.pageNumber=1;
	}

	onnextpage()
	{
		this.pageNumber++;
	}

	onsort()
	{
		const targetColumn = event.target.closest('th');

		if( targetColumn instanceof HTMLDataTableColumn && targetColumn.sortable )
		{
			targetColumn.toggle();

			for( let column of this.view.columns )
			{
				if ( !(column === targetColumn) )
					column.ascending = undefined;					
			}
			
			this.view.sortcolumn = targetColumn;
		}
	}

	fillRequest( form )
	{
		form.set('order', (this.view.sortcolumn != null )? this.view.sortcolumn.id : null );
		form.set('ascending', (this.view.sortcolumn != null)? this.view.sortcolumn.ascending : null);
	}

	insertColumn( input )
	{
		const column = new HTMLDataTableColumn();
		
		column.value = input.value;
		column.cellType = input.type;
		column.map = input.reader;
		column.id = input.id;

		this.view.insertColumn( column );
	}

	insertRow( input )
	{
		const tr = new HTMLDataTableRow();

		for( let col of this.view.columns )
		{
			let cell = new col.cellType;

			tr.appendChild(cell);

			if ( col.map == null )
				cell.value = '';
			else
				cell.value = col.map(input);

		}	

		this.view.insertRow( tr );
	}

	set rows( input )
	{
		this.view.clear();
		
		if (input instanceof Array && input.length > 0 )
		{
			for( let value of input ) 
				this.insertRow(value)
		}
		else
		{
			this.view.message('No data available.');
		}
	}



};

class HTMLDataTablePaginatorController
{
	constructor()
	{
		this.view = new HTMLDataTablePaginatorElement();
		this.pageNumber = 1;		

		this.view.paginator._pagesize.addEventListener('input', event =>
		{
			this.pageNumber=1;
		});
		
		this.view.paginator.next.addEventListener('click', event => 
		{
			this.pageNumber++;
		});

		this.view.paginator.last.addEventListener('click', event => 
		{
			alert('not implemented');
		});

		this.view.paginator.first.addEventListener('click', event => 
		{
			this.pageNumber=1;
		});
		
		this.view.paginator.previous.addEventListener('click', event =>
		{
			( this.pageNumber > 1 )? this.pageNumber-- : this.pageNumber=1;
		});
	}

	
	attachProperties()
	{
		const form = {};

		form['pagesize'] = this.view._pagesize.value;
		form['page'] = 	this.pageNumber;

		return form;
	}



	

}


let dt = new HTMLDataTableController();
let pg = new HTMLDataTablePaginatorController();



const xhr = new XMLHttpRequest();
const form = new Map();

form.set('order', (dt.view.sortcolumn != null )? dt.view.sortcolumn.id : null );
form.set('ascending', (dt.view.sortcolumn != null)? dt.view.sortcolumn.ascending : null);
form.set('pagesize', pg.view._pagesize.value);
form.set('page', pg.pageNumber );

xhr.addEventListener('loadend', event => 
{
	

});



xhr.open('post', 'http://localhost/js-web-components/7.0/test-100-items.php' );




dt.insertColumn( {id: 'name', 		value: 'Employee',	type: HTMLTextCell,		sortable:true,	reader: input => input.name, } );
dt.insertColumn( {id: 'email', 		value: 'Email', 	type: HTMLEmailCell,	sortable:false,	reader: input => input.email.toLowerCase() } );
dt.insertColumn( {id: 'birthday', 	value: 'Birthday',	type: HTMLTextCell, 	sortable:false,	reader: input => input.birthday } );
dt.insertColumn( {id: 'salary', 	value: 'Salary',	type: HTMLTextCell, 	sortable:false,	reader: input => input.salary } );

dt.view.primaryKey = input => input.index;
dt.view.columns[0].sortable = true;


document.body.appendChild(dt.view);

xhr.send( form.json() );




</script>